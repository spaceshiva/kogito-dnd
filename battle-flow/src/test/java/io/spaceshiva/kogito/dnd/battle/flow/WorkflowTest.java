package io.spaceshiva.kogito.dnd.battle.flow;

import java.util.HashMap;
import java.util.Map;

import javax.inject.Inject;
import javax.inject.Named;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.tomakehurst.wiremock.WireMockServer;
import io.quarkus.test.junit.QuarkusTest;
import io.restassured.RestAssured;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.kie.kogito.Model;
import org.kie.kogito.process.Process;
import org.kie.kogito.process.ProcessInstance;

import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
import static com.github.tomakehurst.wiremock.client.WireMock.containing;
import static com.github.tomakehurst.wiremock.client.WireMock.post;
import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;
import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;
import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.kie.api.runtime.process.ProcessInstance.STATE_COMPLETED;

@QuarkusTest
public class WorkflowTest {

    private static WireMockServer sink;

    static {
        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
    }

    // this is the name of the process generated by Kogito. It is the workflow id. :)
    @Named("battleflow")
    @Inject
    Process<? extends Model> battleFlow;
    @Inject
    ObjectMapper objectMapper;

    @BeforeAll
    public static void startSink() {
        sink = new WireMockServer(options().port(8383));
        sink.start();
        sink.stubFor(post("/").willReturn(aResponse().withBody("ok").withStatus(200)));
    }

    @AfterAll
    public static void stopSink() {
        if (sink != null) {
            sink.stop();
        }
    }

    @Test
    public void testJsonServiceCallWorkflow() throws Exception {
        // TODO: set a Knative listener Emitter{channel:'kogito_outgoing_stream'} has no downstream

        assertNotNull(battleFlow);

        Model m = battleFlow.createModel();
        Map<String, Object> parameters = new HashMap<>();

        final Character player = new Character();
        player.setName("Sheldon Cooper");
        player.setArmor(5);
        player.setClazz("Physicist");
        player.setDexterity(2);
        player.setStrength(4);
        player.setHitPoints(20);

        final Character enemy = new Character();
        enemy.setName("Imppy, the Imp");
        enemy.setArmor(1);
        enemy.setClazz("Imp");
        enemy.setDexterity(1);
        enemy.setStrength(1);
        enemy.setHitPoints(5);

        final Battle battle = new Battle();
        battle.setEnemy(enemy);
        battle.setPlayer(player);

        final JsonNode workflowDataInput = objectMapper.readTree(objectMapper.writeValueAsString(battle));
        parameters.put("workflowdata", workflowDataInput);
        m.fromMap(parameters);

        ProcessInstance<?> processInstance = battleFlow.createInstance(m);
        processInstance.start();
        assertEquals(STATE_COMPLETED, processInstance.status());

        Model result = (Model) processInstance.variables();
        assertEquals(1, result.toMap().size());
        JsonNode workflowDataNode = (JsonNode) result.toMap().get("workflowdata");
        assertNotNull(workflowDataNode);
        assertEquals("Sheldon Cooper", workflowDataNode.get("player").get("name").textValue());
        assertEquals("Imppy, the Imp", workflowDataNode.get("enemy").get("name").textValue());
        assertTrue(workflowDataNode.get("enemy").get("dead").asBoolean());

        Thread.sleep(2000);
        // our message must have the name of the player
        sink.verify(postRequestedFor(urlEqualTo("/")).withRequestBody(containing("kogito.dnd.battle.over")));
    }
}
